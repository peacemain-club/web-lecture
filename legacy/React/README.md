# React

프론트엔드 프레임워크 React

## React란?

프론트엔드 프레임워크

### Facebook이 ReactJS를 만들게 된 이유

새로운 디자인 패턴

기존의 MVC(모델 - 뷰 - 컨트롤러)패턴

![MVC](https://blog.kakaocdn.net/dn/ALrHe/btqBTMSuHfN/ZlW9i9ET34e90APgCRChk1/img.png)

Model과 View 사이에 양방향으로 바인딩 되어 있음.

Model의 값이 변하면 View에 보여지는 값도 바뀌어야 하고, View에서 값이 바뀌면 Model에도 업데이트를 해줘야 함.

거대한 시스템을 만들경우 서로 어떠한 방식으로 뷰를 업데이트 시켜줄지 로직을 정해줘야 하고 서로 엉켜서 업데이트가 안되는 경우도 있고 어쨌든 많이 복잡.

그래서 Facebook에서 새로운 디자인 패턴을 생각해냄.

Flux : 데이터 방향이 단방향인 디자인 패턴

![Flux](https://velopert.com/wp-content/uploads/2016/04/flux-simple-f8-diagram-with-client-action-1300w.png)

View에서 바로 Model(Store)의 값을 변형하지 못하고 Dispatcher를 통해서만 변경이 가능

⇒ 나중에 Redux라는 모듈로 만들어짐. 이외에도 MobX 등이 있음

### Virtual DOM

변화가 복잡하다. (문제점)

그래서 어떻게 업데이트를 해줘야 하는가에 대한 고민없이 그냥 바뀔때 마다 다 날려버리고 새로운 DOM을 만들어서 보여주자는 생각.

브라우저의 작동방식

![브라우저](https://d2.naver.com/content/images/2015/06/helloworld-59361-3.png)

* HTML을 받아옴
* 브라우저의 엔진이 파싱
* DOM의 Node로 이루어진 트리 생성
* Style(CSS)을 붙임
* RenderTree를 생성 (여기서 스타일을 다른 요소를 참조하는 등의 과정을 포함해서 컴퓨팅을 함)
* 레이아웃 과정을 거치면서 각 노드들이 화면의 어느 위치에 나타나야 하는지 위치를 받음
* 페인팅 과정을 거치며 색을 입히며 원하는 정보가 나타남

DOM에 변화가 생기면 RenderTree가 재생성 되면서 다시 컴퓨팅을 하고 레이아웃을 만들고 페인팅을 함.

DOM이 많이 바뀔경우 컴퓨팅을 많이하게됨 (연산량 증가) → 비효율적

30개의 노드가 변할 경우, 30번의 레이아웃 계산이 필요함.

DOM을 매번 새로 만들면 속도가 굉장히 느릴것.

그래서 새로운 방식을 생각함.

Virtual DOM을 만들어서 가상 렌더링을 해보고 그 연산이 끝나고 나서 변화된 부분만 실제 DOM에 전달. 모든 변화를 하나로 묶어서 한번만 렌더링.(컴퓨팅이 훨씬 줄어드는 장점)

[React and the Virtual DOM](https://www.youtube.com/watch?v=BYbgopx44vo)

최적화를 수동적으로 '잘' 해주면 React를 사용하는 것보다 빠르지만 복잡함.

React는 개발이 편리하고, 최적화도 어느정도 잘 되어있기 때문에 장점이 있음.

### React의 장점

1. 생태계가 크다

  웹 개발에 있어서 React 사용자가 70%를 찍은 적이 있을 정도로 많은 사람이 사용함.

  그만큼 사용할 수 있는 모듈도 많음

2. 사용하는 곳이 많다.

  우리나라에서도 카카오, 네이버, 라인, 쿠팡, 배달의 민족, 토스 등 많은 IT회사에서 사용함. 해외의 경우에도 페이스북, 인스타그램, 에어비엔비, 트위치 등 수많은 서비스에 사용되고 있음.

## JSX

JavaScript XML

UI를 구성할 때, React 엘레먼트를 생성하기 위한 것.

## Component

UI를 구성하는 단위. 여러개의 컴포넌트가 모여서 화면을 구성. 

* UI를 재사용 가능한 개별적인 조각으로 나눌 수 있음.
* 개별적으로 UI 작동이 가능

### Component의 종류

#### 함수형 컴포넌트

```js
function Component() {
  return (
    <div>Component</div>
  )
}
```

함수의 형태로 컴포넌트를 생성하는 방법. 따로 내장된 메소드가 없어서 보다 가벼움. 기본적으로 state가 없음.

최근엔 대체적으로 함수형 컴포넌트를 사용.

#### 클래스형 컴포넌트

```js
class Component extends React.Component {
  render(
    return (
      <div>Component</div>
    )
  )
}
```

React 모듈에 포함된 컴포넌트 클래스를 상속하여 컴포넌트를 생성하는 방법. 여러가지 메소드가 내장되어 있음. state와 라이프사이클이 존재.

최근엔 쓰이지 않는 추세.


## State와 Props

### State

현재 컴포넌트의 상태.

변화하는 방법

* setState 메소드 사용 (클래스형 컴포넌트)
* hook의 2번째 요소 함수 사용 (함수형 컴포넌트)

왜 컴포넌트에서 그냥 변수를 사용하지 않고, state를 사용할까?

최적화를 하는 알고리즘. Facebook에서 React에 적용한 최적화 알고리즘이 상태의 변화를 State가 변할 때(setState 함수가 호출될 때)만 인지를 하기 때문.

state는 immutable(불변성, 값을 바꿀 수 없음)한 속성. 그래서 바꾸려면 setState 함수를 호출해서 그 자체를 다른 객체로 교체를 해야함.

왜 이렇게 하는가?

* 변수가 수정이 가능하면 side Effect가 발생할 수 있음. (예상치 못한 값의 변화가 생길 수 있는 등 부작용)
* setState함수가 호출되고, state를 비교해야함. 비교를 할 때 객체는 고유의 id를 가지고 있기 때문에 === 으로 비교했을 때 객체가 교체되었을 경우 false를 반환하기에 비교가 더 쉬움

### Props

부모 컴포넌트로부터 받아온 값.

React 컴포넌트 데이터는 방향성이 위→아래만 가능

![Props and state](https://blog.kakaocdn.net/dn/rH4LA/btqF16Gn9C4/yUtBnxdij7DpdL7ySN6IQ0/img.png)

위로는 데이터가 이동할 수 없기 때문에 형제나 부모에게 직접 데이터를 전달 할 수 없음.

형제나 부모에게 데이터를 전달할 수 있는 방법은

* 부모에게 있는 state를 바꿀 수 있는 setState함수를 props로 넘겨주는 방법
* Redux나 MobX와 같은 글로벌 상태관리를 사용하는 방법


## React Router

### SPA

Single Page Application

페이지가 1개인 어플리케이션.

이제까지의 웹은 URL마다 페이지를 새로 받아와서 렌더링 해주는 방식.

SPA를 사용하면 웹서버에서 별다른 코딩 없이 클라이언트(유저가 대면하는 브라우저) 사이드에서 해결을 할 수 있음.

### 클라이언트 사이드 렌더링 vs 서버사이드 렌더링

이제까지의 전통적인 방법은 주소 (예. www.github.com/wingtree)를 입력할 경우 해당 주소에 맞는 html, css, js 파일을 데이터와 함께 렌더링 해서 클라이언트에게 보내주는 방식. www.github.com/facebook을 입력해서 해당 주소로 갈 경우에는 다른 파일이 나온다.

최근에는 웹이 엄청나게 큰 규모이기 때문에 속도적인 측면에서 문제점이 있음. (페이지 이동 시, 로딩 시간이 긴 문제 등)

그래서 클라이언트(각자의 컴퓨터와 브라우저)에서 처음 그 사이트에 접속시 모든 html, css, js 파일을 내려 받아서 기본적인 틀은 클라이언트가 가지고 있도록 한뒤에, 필요한 데이터만 그때 그때 요청해서 클라이언트 사이드에서 렌더링을 하는 방식이 나오게 됨. 이게 클라이언트 사이드 렌더링.

둘 다 장단점이 있음

#### 클라이언트 사이드 렌더링의 장점

- 중앙 서버의 부하가 적음 : 데이터만 받기 때문
- UX : 페이지 이동 시에 새로고침이 없어서 매끄럽게 넘어가는 느낌을 받을 수 있고, 로딩시간도 비교적 짧음

#### 클라이언트 사이트 렌더링의 단점

- 검색엔진이 인지를 잘 못함 : 검색엔진이 인지를 못해서 텅빈 페이지로 인식할 수 있음. 그래서 SEO(검색엔진 최적화)에 악영향을 미칠 수 있음. 그렇지만 구글에서는 제대로 크롤링을 하고 있어서 앞으로는 해결될 문제로 보임. (아직 네이버나 다음의 검색엔진은 제대로 크롤링 하지 못하고 있음)

#### 서버 사이드 렌더링의 장점

- 검색엔진 최적화 가능 : 위의 문제가 없음. 가장 큰 장점.
- 최초 로딩이 빠름

### 라우팅

네트워크에서 주소를 이용해서 해당 목적지까지 이동하기 위한 경로선택 과정. 간단하게 말하면, 다른 주소에 따라 다른 뷰를 보여주는 것.

클라이언트 사이드 렌더링이라도 이런 기능들이 필요함.

리액트에는 이 기능이 내장되어 있지 않음. 그래서 써드파티(다른 사람이 만든 모듈)을 사용해야 하는데, 가장 많이 쓰이는 모듈이 `react-router-dom` 

## 글로벌 상태관리

투두리스트를 만들다가 느낀점. state는 그 컴포넌트에서만 사용이 가능하고, props는 아래로만 내려줄 수 있다. 형제나 사촌 또는 그 이상의 촌수의 형제에게는 어떻게 넘겨줄까?

글로벌로 상태를 만들어서 바로 모든 컴포넌트에 쏴주면 쉽지 않을까?

![Globa state management](https://blog.kakaocdn.net/dn/by6NxO/btqzf4PQpOb/yuDnSUKSVUi9oOWFhrsP90/img.png)

그래서 나온게 글로벌 상태관리라는 개념

많은 글로벌 상태관리 라이브러리가 있지만 유명한 것은 Redux, MobX, React의 Context API등이 있다. 여기서는 Redux를 사용해서 글로벌 상태관리를 해볼 것.

### Redux

Redux는 Flux라는 디자인 패턴을 사용함.

![Flux](https://camo.githubusercontent.com/9306ed614b068af5291fb233e82750be4181410a/68747470733a2f2f76656c6f706572742e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30342f666c75782d73696d706c652d66382d6469616772616d2d776974682d636c69656e742d616374696f6e2d31333030772e706e67)

Redux는 처음에 이해하기가 아주 어려움. 그래서 기본적인 개념을 들어가기 전에 위의 용어들을 좀 더 이해하기 쉽게 먼저 용어들을 정리해보자.

- View는 우리가 만드는 컴포넌트. 마치, 연예인 사진을 받고 연예인에게 조공을 바치는 팬과 같은 존재
- Store는 '글로벌' 상태관리이기 때문에 글로벌 그 어딘가에 존재하는 저장소. 마치, 연예인과 같은 존재.
- Action은 컴포넌트에 있는 버튼과 같은 것을 눌러서 실행되는 함수로 글로벌 상태를 가져와라, 업데이트 하라, 지워라, 새로 만들어라 등의 명령으로 생각하면 될 듯. 마치, 연예인에게 조공을 바칠때 필요한 양식(서류)과 조공 같은 것.
- Dispatcher는 Action을 받아와서 실질적으로 Store를 조작할 수 있는 녀석. 마치, 팬들이 주는 조공을 서류를 보고 OK, 안돼 돌아가. 이런것을 결정하고 연예인과 대면해서 넘겨줄 수 있는 매니저 또는 소속사와 같은 존재.

흐름을 연예인과 팬, 소속사의 삼각관계로 표현을 해보자.

```
연예인이 너무 좋아서 사진을 막 다운받고 조공도 바치고 싶은 팬이 있다.
이 연예인이 소속된 소속사는 연예인을 아주 신성한 존재로 생각해서 감히 팬들이 연예인에게 바로 접근 못하게
싸인회도 안 열어준다. 오직 자기를 통해서만 뭔가를 할 수 있도록 하는 아주 이상한 소속사다.
그래서 팬은 조공을 바치려고 하는데, 또 그냥 막 보낼 수가 없다고 한다. 조공을 바치려거든 양식에 맞춰서
보내야만 한다고 한다. 팬은 이 소속사가 너무 싫지만 연예인이 너무 좋아서 어쩔 수 없이 양식을 맞춰서
소속사에 조공과 함께 보냈다. 그러자 소속사는 그 양식과 조공을 보고 검토를 해보고 연예인에게 넘겨줬다.
그러자 연예인은 그 조공 받은 물건을 가지고 TV 예능에 나왔고 팬은 자신이 보낸 조공품을 가진 연예인의 사진을
다운받아서 행복한 날을 보냈다.
```

좀 더 자세하게 기술적으로 용어를 살펴보면,

- View는 역시 우리가 만드는 컴포넌트. 달리 표현할 방법이 없음.
- Store는 하나의 거대한 객체. 객체안에는 뭐든지 들어갈 수 있기 때문에 이 안에서 모든 상태가 관리됨.
- Action은 이벤트와 같은 것. 이 Action에는 이벤트의 타입, 그리고 이 Action 실행에 필요한 데이터가 포함이 된다.
- Dispatcher는 Reducer로 볼 수 있음. Reducer라는 용어는 합성곱을 의미함. 원래 있던 것을 기반으로 어떻게 어떻게 연산을 해서 값을 도출해 나가는 것. Action을 받아서 그걸 보고 Store를 직접적으로 수정할 수 있음.

흐름을 다시 기술적으로 표현해보면,

```
어떤 컴포넌트에서 글로벌로 관리되고 있는 상태를 업데이트 해야한다. 바로 스토어에 접근해서 받아올 수는 없기
때문에 type과 payload가 포함된 Action을 실행했다. 리듀서에서 type을 보고 그에 맞는 함수를 실행
해서 스토어에 있는 값을 업데이트 했다.
```

다른 MobX나 Context API도 비슷한 원리로 구현이 되어 있음. 각각의 특징이 있으니 그에 맞는 것을 골라서 사용하면 됨.

## React Hook

함수형 컴포넌트와 클래스형 컴포넌트의 차이점은 클래스형 컴포넌트는 리액트가 제공하는 다양한 메소드를 사용할 수 있지만(예. state, componentDidMount 등), 함수형 컴포넌트는 그냥 함수라서 따로 메소드가 없는 것이 었음.

그래서 함수형 컴포넌트는 주로 상태가 없는 간단한 컴포넌트로 사용을 했지만, React Hook을 통해 기존의 클래스형 컴포넌트에서만 사용이 가능했던 대부분의 메소드를 사용할 수 있게 되면서 클래스형 컴포넌트보다 함수형 컴포넌트가 주로 사용되게 됨.

- useState
- useEffect
- useContext
- useReducer
- useMemo
- useCallback
- useRef

많은 종류의 Hook이 있고, use~~ 형식으로 만드는 필요한 기능이 들어있는 커스텀 hook도 만들 수 있음.

여기서는 가장 많이 쓰이는 useState와 useEffect를 다룰 것.

### useState

state를 다룰 때 사용을 해본 내용. 가장 기본적인 hook으로 함수형 컴포넌트에서도 수정이 가능한 state를 사용할 수 있게 해줌.

useState 함수를 실행하게 되면 길이가 2인 배열이 생성되는데 0번째 요소에는 state, 1번째 요소에는 그 state를 변경이 가능한 함수가 들어있음. 왜 이 함수를 사용해야 하는가는 불변성에 대한 내용을 다시 읽어보자.

state를 다룰 때 사용도 해봐서 여기까지 하고 넘어가자.

### useEffect

React 컴포넌트가 렌더링 될 때마다 특정 작업을 할 수 있게 해주는 hook. 가장 처음 컴포넌트가 렌더링이 될 때, state가 바뀌어서 다시 렌더링이 될 때, 어떤 작업을 수행해야 할 경우 사용할 수 있다.

 *참고 : 가장 처음 렌더링되는 것을 컴포넌트가 마운트(Mount, 올라온다)라고 표현하기도 함

예시로 이해를 해보자.

- 네이버의 메인 페이지가 처음 마운트되고, default가 뉴스탭일 때, 뉴스 데이터들을 받아와야 하니 useEffect 안에 데이터를 받아오는 함수를 넣어서 데이터를 받아올 수 있다.
- 증권탭으로 바꿀 경우, state가 `news` 에서 `finance` 로 바뀌고 다시 렌더링 된다. 이때에 증권과 관련된 데이터를 받아와야 하니 useEffect 안에 데이터를 받아오는 함수를 넣어서 데이터를 받아올 수 있다.

#### 처음 마운트 될 때만 실행하고 싶을 때

```jsx
useEffect(() => {
	console.log('가장 처음 마운트 될 때만 실행');
}, []);
```

state가 변경되더라도 함수는 실행되지 않음

#### 특정 값이 업데이트 될 때만 실행하고 싶을 때

```jsx
const [name, setName] = useState('');

useEffect(() => {
	console.log('가장 처음이랑, name이 변할 때만 실행');
}, [name]);
```

가장 처음 마운트 될 때와, name state가 변경이 될 때만 실행됨.

#### 정리하기

```jsx
useEffect(() => {
	console.log('렌더링 될 때 마다 실행');
	return () => {
		console.log('컴포넌트가 언마운트 될 때, 업데이트 되기 전에 실행');
	}
}}
```

정리는 언제 필요한가? 실시간으로 받아오는 종류의 함수나 이벤트 리스너와 같은 것은 계속 연결되어 있기 때문에 그 컴포넌트에서 나갈 때 해지 해야함.
